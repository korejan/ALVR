#![allow(non_upper_case_globals, non_snake_case, clippy::missing_safety_doc)]

mod connection;
mod connection_utils;

use std::ffi::CString;

// mod logging_backend;

// #[cfg(target_os = "android")]
// mod audio;

include!(concat!(env!("OUT_DIR"), "/oxr_bindings.rs"));

use alvr_common::{
    data::{self, HeadsetInfoPacket, PrivateIdentity, ALVR_VERSION},
    logging,
    prelude::*,
};
// // use jni::{
// //     objects::{JClass, JObject, JString},
// //     JNIEnv,
// // };
use lazy_static::lazy_static;
use parking_lot::Mutex;
use std::{
    ptr, slice,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc,
    },
};
use tokio::{runtime::Runtime, sync::mpsc, sync::Notify};

lazy_static! {
    static ref MAYBE_RUNTIME: Mutex<Option<Runtime>> = Mutex::new(None);
    static ref IDR_REQUEST_NOTIFIER: Notify = Notify::new();
    static ref IDR_PARSED: AtomicBool = AtomicBool::new(false);
    static ref MAYBE_LEGACY_SENDER: Mutex<Option<mpsc::UnboundedSender<Vec<u8>>>> =
        Mutex::new(None);
    static ref ON_PAUSE_NOTIFIER: Notify = Notify::new();
}

pub extern "C" fn init_connections() {
    //println!("Hello world\n");
    logging::show_err(|| -> StrResult {

        println!("Hello world\n");
        
        // // struct OnResumeResult {
        // //     DeviceType deviceType;
        // //     int recommendedEyeWidth;
        // //     int recommendedEyeHeight;
        // //     float *refreshRates;
        // //     int refreshRatesCount;
        // // };

        // let java_vm = trace_err!(env.get_java_vm())?;
        // let activity_ref = trace_err!(env.new_global_ref(jactivity))?;
        // let nal_class_ref = trace_err!(env.new_global_ref(nal_class))?;

        //let result = onResumeNative(*jscreen_surface as _, dark_mode == 1);

        let device_name = "WMR";/*if result.deviceType == DeviceType_OCULUS_GO {
            "Oculus Go"
        } else if result.deviceType == DeviceType_OCULUS_QUEST {
            "Oculus Quest"
        } else if result.deviceType == DeviceType_OCULUS_QUEST_2 {
            "Oculus Quest 2"
        } else {
            "Unknown device"
        };*/

        let available_refresh_rates = vec![90.0];
            //slice::from_raw_parts(result.refreshRates, result.refreshRatesCount as _).to_vec();
        let preferred_refresh_rate = 90.0;//available_refresh_rates.last().cloned().unwrap_or(60_f32);

        let headset_info = HeadsetInfoPacket {
            recommended_eye_width: 1440, //result.recommendedEyeWidth as _,
            recommended_eye_height: 1440, //result.recommendedEyeHeight as _,
            available_refresh_rates,
            preferred_refresh_rate,
            reserved: format!("{}", *ALVR_VERSION),
        };

        let private_identity = data::create_identity(Some(std::net::Ipv4Addr::LOCALHOST.to_string())).unwrap();/*PrivateIdentity {
            hostname: "127.0.0.1:8080".to_string(), //trace_err!(env.get_string(jhostname))?.into(),
            certificate_pem: "".to_string(), //trace_err!(env.get_string(jcertificate_pem))?.into(),
            key_pem: "".to_string(), //trace_err!(env.get_string(jprivate_key))?.into(),
        };*/

        let runtime = trace_err!(Runtime::new())?;

        runtime.spawn(async move {
            let connection_loop = connection::connection_lifecycle_loop(
                headset_info,
                device_name,
                private_identity,
                // Arc::new(java_vm),
                // Arc::new(activity_ref),
                // Arc::new(nal_class_ref),
            );

            tokio::select! {
                _ = connection_loop => (),
                _ = ON_PAUSE_NOTIFIER.notified() => ()
            };
        });

        *MAYBE_RUNTIME.lock() = Some(runtime);

        Ok(())
    }());
}

extern "C" fn legacy_send(buffer_ptr: *const u8, len: u32) {
    if let Some(sender) = &*MAYBE_LEGACY_SENDER.lock() {
        let mut vec_buffer = vec![0; len as _];

        // use copy_nonoverlapping (aka memcpy) to avoid freeing memory allocated by C++
        unsafe {
            ptr::copy_nonoverlapping(buffer_ptr, vec_buffer.as_mut_ptr(), len as _);
        }

        sender.send(vec_buffer).ok();
    }
}

fn main() {
    unsafe
    {
        let ctx = Box::new(crate::RustCtx {
            initConnections: Some(init_connections),
            legacySend: Some(legacy_send),
        });
        crate::openxrMain(ctx.as_ref());
    }
}
